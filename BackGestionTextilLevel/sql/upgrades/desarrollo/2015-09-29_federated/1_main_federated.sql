-- (0) 
  
Habilitar engine "federated" en la B

Levantar el JBOSS (de la B) con la nueva versión

EJECUTAR SCRIPTS 2_run_grants.sql  EN LA A

-- (1) CREO LA TABLA QUE TENDRÁ LOS NOMBRES DE TABLAS A MIGRAR JUNTO A LAS TABLAS QUE ELLAS HACEN REFERENCIA.
--	   TODAS LAS TABLAS QUE APARECEN SON LAS QUE DESPUÉS SE CREARÁN COMO "FEDERATED" Y LAS DE A_NIVEL=1 SON LAS QUE HABRÁ QUE REAPUNTAR EN EL MOVIMIENTO DE DATOS (PASO 9) 

CREATE TABLE `gtltest`.`T_MIG_TABLAS` (
  `A_NOMBRE_TABLA` VARCHAR(100) NULL,
  `A_NIVEL` INT NULL,
  `A_NOMBRE_TABLA_EQUIV` VARCHAR(100) NULL
);

-- (2) INSERTO LAS TABLAS A MIGRAR 
CORRER 3_insert_mig_tablas.sql EN LA B;


-- (3) EJECUTAR SCRIPTS EN LA B QUE INICIALIZAN LAS TABLAS DE EQUIVALENCIA
T_CLIENTE_EQUIV.sql
T_COND_VENTA_EQUIV.sql
T_PROVEEDORES_EQUIV.sql
T_ARTICULO_EQUIV.sql
T_PERSONA_EQUIV.sql
T_PRECIO_MATERIA_PRIMA_EQUIV.sql
T_REL_CONT_PREC_MAT_PRIMA_EQUIV.sql
T_PRODUCTO_EQUIV.sql

-- (4) CREO LA TABLA QUE ALMACENARÁ LAS CONSTRAINTS QUE SE DROPEARAN
CREATE TABLE `gtltest`.`T_MIG_CONSTRAINTS` (
  `A_TABLA_PADRE` VARCHAR(100) NOT NULL,
  `A_TABLA_OWNER_CONST` VARCHAR(100) NOT NULL,
  `A_CONSTRAINT_NAME` VARCHAR(100) NOT NULL,
  `A_COLUMNA_CONSTRAINT` VARCHAR(100) NOT NULL,
  PRIMARY KEY (`A_CONSTRAINT_NAME`)
);

-- (5) LLENO LA TABLA T_MIG_CONSTRAINTS POR CADA ENTRADA DE LA TABLA T_MIG_TABLAS
INSERT INTO T_MIG_CONSTRAINTS (A_TABLA_PADRE, A_TABLA_OWNER_CONST, A_CONSTRAINT_NAME, A_COLUMNA_CONSTRAINT)
SELECT T1.A_NOMBRE_TABLA, UPPER(M1.TABLE_NAME), M1.CONSTRAINT_NAME, M1.COLUMN_NAME
FROM T_MIG_TABLAS T1
INNER JOIN information_schema.KEY_COLUMN_USAGE M1 ON M1.REFERENCED_TABLE_NAME = T1.A_NOMBRE_TABLA AND M1.REFERENCED_COLUMN_NAME = 'P_ID'
WHERE M1.CONSTRAINT_SCHEMA='gtltest' AND M1.TABLE_SCHEMA='gtltest'
GROUP BY T1.A_NOMBRE_TABLA, M1.TABLE_NAME, M1.CONSTRAINT_NAME, M1.COLUMN_NAME
ORDER BY T1.A_NOMBRE_TABLA, M1.TABLE_NAME;


-- (6) BORRO TODAS LAS CONSTRAINTS DE LA TABLA T_MIG_CONSTRAINTS (SON LAS QUE APUNTAN A TABLAS QUE SERAN FEDERATED)
INSTALAR SP 5_sp_drop_constraints.sql
CALL DROP_CONST();
-- chequear si las constraints fueron borradas tirando el select de arriba


-- (7) RENOMBRAR TABLAS
INSTALAR SP 6_sp_rename_tables.sql
CALL RENAME_TABLAS();
-- chequear si las tablas fueron renombradas haciendo refresh y ejecutando:
select count(*) from information_schema.tables tt where tt.table_schema='gtltest' and upper(tt.table_name) like '%OLD';

-- (8) CREAR TODAS LAS TABLAS NUEVAS (FEDERATED) 
EJECUTAR 7_create_federated_tables.sql EN LA B;


-- (8.1) INSTALAR Y EJECUTAR EL DEBUG Y VER EL STATUS DE LOS REGISTROS PARA ACTUALIZAR, DEBERIA DAR UNA CANTIDAD DIFERENTE A CERO P/ CADA ENTRADA  

CREATE TABLE `gtltest`.`T_DEBUG_MIG_CONSTRAINTS` (
  `A_TABLA_PADRE` VARCHAR(100) NOT NULL,
  `A_TABLA_OWNER_CONST` VARCHAR(100) NULL,
  `A_COLUMNA_CONSTRAINT` VARCHAR(100) NOT NULL,  
  `A_CANT_REGISTROS` INT(10) NULL
);

INSTALAR SP 7.1_debug_migrador_datos.sql
CALL DEBUG_MIGRAR_DATOS();
SELECT * FROM T_DEBUG_MIG_CONSTRAINTS;

-- (9) HAGO EL MOVIMIENTO DE DATOS SOLO DE TABLAS QUE REFERENCIAN A LAS DE A_NIVEL=1 USANDO LAS TABLAS DE EQUIVALENCIA.
--	   (LAS CONSTRAINT NO SE REGENERAN PORQUE NO SE SOPORTAN FK A UNA TABLA FEDERATED!!!)
INSTALAR SP 8_migrador_datos.sql
CALL MIGRAR_DATOS();

-- (10) LLAMAR NUEVAMENTE AL DEBUG Y VER QUE TODAS LAS CANTIDADES SON = 0

CALL DEBUG_MIGRAR_DATOS();

SELECT * FROM T_DEBUG_MIG_CONSTRAINTS;



-- PARA SABER QUÉ TABLAS REFERENCIAN A T_CLIENTE
select *
from information_schema.KEY_COLUMN_USAGE
where REFERENCED_TABLE_NAME = 'T_CLIENTE' AND REFERENCED_COLUMN_NAME = 'P_ID';

-- PARA SABER QUÉ TABLAS REFERENCIA T_CLIENTE
select a.table_name, b.referenced_table_name
from information_schema.TABLE_CONSTRAINTS a
inner join information_schema.KEY_COLUMN_USAGE b on b.constraint_name=a.constraint_name
where a.table_name = 'T_CLIENTE' and a.constraint_name not in ('PRIMARY') AND b.referenced_table_name is not null;
